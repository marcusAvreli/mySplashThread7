package mySplashThread7.gui;

import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Vector;

import javax.swing.GroupLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.LayoutStyle;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import mySplashThread7.DemoPaginationBar;
import mySplashThread7.dynagent.common.utils.RowItem;
import mySplashThread7.events.Event;
import mySplashThread7.events.EventBroker;
import mySplashThread7.events.EventConsumer;
import mySplashThread7.events.OnLoadPaneView;
import mySplashThread7.events.UpdateFindings;
import mySplashThread7.gdev.gawt.GTable;
import mySplashThread7.gdev.gawt.GTableModelReduction;
import mySplashThread7.gen.GConst;
import mySplashThread7.gfld.GFormTable;
import mySplashThread7.gfld.GTableColumn;
import mySplashThread7.gfld.GTableRow;
import mySplashThread7.jlawyer.client.utils.TableUtils;
import mySplashThread7.model.base.dao.CustomApplicationDAO;
import mySplashThread7.model.base.entity.CustomApplication;
import mySplashThread7.nepxion.swing.locale.SwingLocale;
import mySplashThread7.nepxion.swing.pagination.PaginationContext;

public class SearchApplicationPanel /*extends MyPagination*/ extends JPanel   {

	private static final Logger logger = LoggerFactory.getLogger(SearchApplicationPanel.class);
	private JButton cmdQuickSearch;
	private Image backgroundImage = null;
	private String token;
	protected JLabel lblPanelTitle;
	private JTextField txtSearchString;
	private JPanel jPanel1;
	private GTable gtable;
	private DemoPaginationBar bar;
	private PaginationContext paginationContext;
	private JButton cmdExport;
	public String getToken() {
		return token;
	}

	public void setToken(String token) {
		this.token = token;
	}

	/**
	 * Creates new form QuickAddressSearchPanel
	 */
	public SearchApplicationPanel() {
		
		logger.info("SearchApplicationPanel_started");
		EventBroker b = EventBroker.getInstance();
		//b.subscribeConsumer(this, Event.TYPE_CUSTOM_APPLICATION_GET_ALL);
		//b.subscribeConsumer(this, Event.TYPE_TOKEN_RECEIVED);
		//b.subscribeConsumer(this, Event.TYPE_LOAD_PANE_VIEW);
		//b.subscribeConsumer(this, Event.TYPE_UPDATE_FINDINGS);
		initComponents();
	    this.txtSearchString.putClientProperty("JTextField.showClearButton", true);
        this.txtSearchString.putClientProperty("JTextField.placeholderText", "Suche: Adressen");
		logger.info("SearchApplicationPanel_finished");

	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed" desc="Generated
	// Code">//GEN-BEGIN:initComponents
	private void initComponents() {
		 txtSearchString = new javax.swing.JTextField();
		 jPanel1 = new JPanel();
		 cmdQuickSearch = new JButton();
    	List<CustomApplication> customApplications = CustomApplicationDAO.getData();
		int size = customApplications.size();
		 paginationContext = new PaginationContext(size);
		 cmdExport = new JButton();
		Vector<GTableColumn> listaColumnas = buildColumns();
		Vector<GTableRow> rows = buildRows(customApplications);
		
		
    	//GFormTable ff = new GFormTable();
    	GFormTable m_objFormField = createTable(listaColumnas,rows);
    
		gtable = new GTable(m_objFormField);
		gtable.createComponent();
		//gtable.getTable();
		
		
		 bar = new DemoPaginationBar(gtable, paginationContext);
		///JScrollPane scrollPane = new JScrollPane(table);
		//JScrollPane scrollPane = new JScrollPane(gtable.getTable());
		//MyPagination pagination = new MyPagination(gtable);
		//setGtable(gtable);
		//setScrollPane(scrollPane);
		//buildPagination();
		//add(pagination);
		//runTroughPages();
		  txtSearchString.addKeyListener(new java.awt.event.KeyAdapter() {
	            public void keyPressed(java.awt.event.KeyEvent evt) {
	               // txtSearchStringKeyPressed(evt);
	            //	logger.info("key pressed");
	            }
	        });
		//  cmdQuickSearch.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/find.png"))); // NOI18N
		  
		  cmdExport.setText(SwingLocale.getString("exportToCsv")); // NOI18N
	        cmdExport.setToolTipText(SwingLocale.getString("exportToCsv"));
	        cmdExport.addActionListener(new java.awt.event.ActionListener() {
	            public void actionPerformed(java.awt.event.ActionEvent evt) {
	                cmdExportActionPerformed(evt);
	            }
	        });

	        cmdQuickSearch.setToolTipText(SwingLocale.getString("search"));
	        cmdQuickSearch.setText(SwingLocale.getString("search"));
	        cmdQuickSearch.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                cmdQuickSearchActionPerformed(evt);
	            	//logger.info("search button pressed");
	            }
	        });
		  jPanel1.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(255, 255, 255), 2, true));
	        jPanel1.setOpaque(false);  
		GroupLayout layout = new GroupLayout(this);
		this.setLayout(layout);
		/*layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
				.addGroup(layout.createSequentialGroup()
						
						
						
						 .addComponent(txtSearchString).addGap(10, 10, 10)
						.addComponent(bar).addGap(10, 10, 10)
						
			

				));*/
		
		  layout.setHorizontalGroup(
		            layout.createParallelGroup(GroupLayout.Alignment.LEADING)
		            .addGroup(layout.createSequentialGroup()
		                .addContainerGap()
		                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
		                    .addComponent(bar, GroupLayout.DEFAULT_SIZE, 651, Short.MAX_VALUE)
		                   // .addComponent(jScrollPane2)
		                    .addGroup(layout.createSequentialGroup()
		                        .addComponent(txtSearchString)
		                        .addComponent(cmdQuickSearch)
		                        .addComponent(cmdExport)
		                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
		                       
		                        .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
		                     //   .addComponent(cmdTagFilter))
		                   )))
		        );
		  /*
		layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
				
				.addComponent(txtSearchString, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
				.addComponent(bar, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
				
				);
*/
		  
		  layout.setVerticalGroup(
		            layout.createParallelGroup(GroupLayout.Alignment.LEADING)
		            .addGroup(layout.createSequentialGroup()
		                .addContainerGap()
		                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
		                	       .addComponent(txtSearchString, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
		                	       .addComponent(cmdQuickSearch,GroupLayout.Alignment.TRAILING)
		                	       .addComponent(cmdExport,GroupLayout.Alignment.TRAILING)
		                  //  .addComponent(bar, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
		                    .addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING, false)
		                      //  .addComponent( lblPanelTitle,GroupLayout.Alignment.LEADING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
		                       // .addComponent(jLabel18, GroupLayout.Alignment.LEADING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
		                        )
		                        )
		                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
		                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
		               //     .addComponent(cmdQuickSearch,GroupLayout.Alignment.TRAILING)
		                		  .addComponent(bar, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
		             //       .addComponent(txtSearchString, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
		                   // .addComponent(cmdTagFilter)
		                    )
		                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
		             //  .addComponent(bar, GroupLayout.DEFAULT_SIZE, 190, Short.MAX_VALUE)
		                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
		               // .addComponent(jScrollPane2, GroupLayout.PREFERRED_SIZE, 104, GroupLayout.PREFERRED_SIZE)
		                .addContainerGap())
		        );
	}
	public PaginationContext getPaginationContext() {
		return paginationContext;
	}

	public void setPaginationContext(PaginationContext paginationContext) {
		this.paginationContext = paginationContext;
	}

	public DemoPaginationBar getBar() {
		
		return bar;
	}

	public void setBar(DemoPaginationBar bar) {
		this.bar = bar;
	}
/*
	public Vector <GTableRow> gSubVector(int startIndex,int endIndex,GFormTable m_objFormField) {
		Vector rowVector = m_objFormField.getRowList();
		Vector<GTableRow> subVector =new Vector<GTableRow>();
		for(int i=0;i<endIndex;i++) {
    	GTableRow object = (GTableRow) rowVector.get(i);
    	
    	subVector.add(0,object);
		}
		return subVector;
	}
	public Image getBackgroundImage() {
		return this.backgroundImage;
	}
*/
	public void reset() {
		this.txtSearchString.requestFocus();
		this.txtSearchString.selectAll();
	}

	public boolean needsReset() {
		return true;
	}

	
	public GTable getGtable() {
		return gtable;
	}

	public void setGtable(GTable gtable) {
		this.gtable = gtable;
	}

	public Vector<GTableColumn> buildColumns() {
		Vector<GTableColumn> listaColumnas = new Vector<GTableColumn>();
		GTableColumn column = buildSelectionColumn();
    	listaColumnas.add(column);   	
    	column = buildName();
		//(String id,		String idParent,	int col,		String 	strLab,		int type,	String ref,		int idProp,		int width,	int height,	int length,		String 	mask,boolean 	enable,		boolean hide,	boolean total,	boolean agrupable,	boolean dobleSizeHeader,boolean nullable,	boolean creation,	int finder,		boolean basicEdition,	boolean uniqueValue,Integer redondeo)
    	
    	listaColumnas.add(column);
    	column = buildDisplayName();
    	listaColumnas.add(column);
    	return listaColumnas;
	}
	public Vector<GTableRow> buildRows(List<CustomApplication> customApplications) {
		Vector<GTableRow> rows = new Vector<GTableRow>();
		GTableRow row = null;
		for(CustomApplication customApplication : customApplications) {
    		String appName = customApplication.getName();
    		String displayName = customApplication.getDisplayName();
    		//idto++;
    		row=new GTableRow();
    		
    		row.setDataColumn("name", appName);
    		row.setDataColumn("displayName", displayName);
    		rows.add(row);    		
    	}	
		return rows;
	}
	  private void cmdQuickSearchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdQuickSearchActionPerformed
	        // perform search here
	      //  EditorsRegistry.getInstance().updateStatus("Suche Adressen...");
	     //   ThreadUtils.setWaitCursor(this);
	      logger.info("search button pressed");  
	        new Thread(new QuickAddressSearchThread(this, this.txtSearchString.getText(),  this.gtable)).start();

	    }
	 public  GFormTable createTable(Vector<GTableColumn> vColumns,Vector<GTableRow> vRows) {
	    	GFormTable table = new GFormTable();
	      //  table.setViewBalancer(m_objViewBalancer);
	      //  table.setId(id);
	      //  table.setLabel(label);
	      //  table.setName(name);
	      //  table.setPriority(priority);
	       // table.setOrder(order);
	      //  table.setEnabled(enable);
	       // table.setNullable(nullable);
	        
	       // table.setVisibleRowCount(rows);
	        //table.setCreationRow(creationRow);
	       // table.setFinderRow(finderRow);
	        Enumeration en = vColumns.elements();
	        while(en.hasMoreElements())
	        {
	            GTableColumn col = (GTableColumn)en.nextElement();
	            table.addColumn(col);
	        }
	        Enumeration enRows = vRows.elements();
	        while(enRows.hasMoreElements())
	        {
	            GTableRow row = (GTableRow)enRows.nextElement();
	            table.addRow(row);
	        }
	        return table;
	    }
	 private void cmdExportActionPerformed(ActionEvent evt) {
		 logger.info("cmd export performed");
		 //GTable table = getGtable();
		 GTableModelReduction tableModel = gtable.getModel();
		 GFormTable formTable = gtable.getGformTable();
		 Vector<GTableColumn> vectorColumn = formTable.getColumnList();
		 Vector<GTableRow> vectorRows = formTable.getRowList();
		 ArrayList selectedRows = gtable.getDataSelectedRows();
		 if(null !=selectedRows) {
			 logger.info("selectedRows:"+selectedRows.size());
		 }else {
			 logger.info("selectedRows is null");
		 }
		 
		 
		 if(tableModel.getColumnSelectionRowTable()!=null){
			 for(RowItem rowItem : tableModel.getRowData()){
					//rowItem.setColumnData(tableModel.getColumnSelectionRowTable(),select);
				Object value=	rowItem.getColumnData(tableModel.getColumnSelectionRowTable());
				int index = rowItem.getIndex();
				
				//tableModel.getr
				if(null !=value) {
					if(value instanceof Boolean) {
						boolean isSelected = (Boolean)value;
						if(isSelected) {
							//logger.info("selected:"+value+" index:"+index);
							//String nameValue = (String) vectorRows.get(index).getDataColumn("name");
							//logger.info("name value:"+nameValue);
							//String objectValue = (String) rowItem.getColumnData(1);
							//logger.info("name value:"+objectValue);
							for(GTableColumn gTableColumn : vectorColumn) {
								String nameColumn = gTableColumn.getId();
								int idColumn = gTableColumn.getColumn();
								String objectValue = (String) rowItem.getColumnData(idColumn);
								logger.info("name value:"+objectValue);
							}
						}
					}
				
				}
		 }
		 }
	     /*try {
	         TableUtils.exportAndLaunch("adresssuche-export.csv", this.tblResults);
	     } catch (Exception ex) {
	         logger.error("Error exporting table to CSV", ex);
	         JOptionPane.showMessageDialog(this, "Fehler beim Export: " + ex.getMessage(), DesktopUtils.POPUP_TITLE_ERROR, JOptionPane.ERROR_MESSAGE);
	     }*/
	 }
	   public  GTableColumn buildSelectionColumn() {
		  	  /** El id de la columna*/
		        String m_iId = "SELECTION";
		        /** El índice de la columna (empezando desde 0)*/
		        int m_iColumn=2;
		        /** El nombre de la columna*/
		        String m_strLabel="";
		        /** El código del tipo de la columna*/
		        int m_iType=GConst.TM_BOOLEAN;
		        /** Si la columna es editable*/
		        boolean m_enable=true;
		    	//No se tiene permiso para modificar este campo.
		        /** Si la columna está oculta o no*/
		        boolean m_hide=false;
		        /** Si se puede resumir en una*/
		         boolean m_total=true;
		        /** Si se puede agrupar en varios valores*/
		        boolean m_agrupable=true;
		        /** Id de la columna*/
		         int m_idProp=0;
		        /** Ancho de la columna*/
		       int m_width=100;
		        /** Alto de la columna*/
		       int m_height=120;
		        /** Longitud de la columna*/
		       int m_length=100;
		        /** */
		       String m_ref="m_ref";
		        /** */
		       boolean m_dobleSizeHeader = false;
		        /** Si acepta el valor nulo*/
		       boolean m_nullable=false;
		        /** Máscara aplicable*/
		       String m_mask="m_mask";
		        
		       
		        
		       boolean m_creation=false;
		        
		       int m_typeFinder=0;
		        
		       boolean m_basicEdition=true;//En principio se permite la edicion de la columna pero siempre que enable este tambien a true
		        
		       boolean m_uniqueValue=false;//Indica si el valor de esta columna tiene que ser unico en base de datos

		       Integer m_redondeo=1;//Para saber el numero de digitos de redondeo en caso de ser un double
		        
		        /** El id del padre de la columna*/
		       String m_iIdParent = null;
		        
		       GTableColumn column = new GTableColumn(			m_iId,		m_iIdParent,		m_iColumn,			m_strLabel,		m_iType,		m_ref,		m_idProp,		m_width,	m_height,	m_length,			m_mask,			m_enable,			m_hide,			m_total,		m_agrupable,		m_dobleSizeHeader,		m_nullable,			m_creation,		m_typeFinder,		m_basicEdition,			m_uniqueValue,m_redondeo);
		       return column;
		    }
	   public  GTableColumn buildName() {
			  /** El id de la columna*/
		      String m_iId = "name";
		    /** El índice de la columna (empezando desde 0)*/
		      int m_iColumn=1;
		    /** El nombre de la columna*/
		      String m_strLabel="Name";
		    /** El código del tipo de la columna*/
		       int m_iType=1;
		    /** Si la columna es editable*/
		       boolean m_enable=true;
			//No se tiene permiso para modificar este campo.
		    /** Si la columna está oculta o no*/
		       boolean m_hide=false;
		    /** Si se puede resumir en una*/
		       boolean m_total=true;
		    /** Si se puede agrupar en varios valores*/
		       boolean m_agrupable=true;
		    /** Id de la columna*/
		       int m_idProp=0;
		    /** Ancho de la columna*/
		       int m_width=100;
		    /** Alto de la columna*/
		       int m_height=120;
		    /** Longitud de la columna*/
		       int m_length=100;
		    /** */
		       String m_ref="m_ref";
		    /** */
		       boolean m_dobleSizeHeader = false;
		    /** Si acepta el valor nulo*/
		       boolean m_nullable=false;
		    /** Máscara aplicable*/
		       String m_mask="m_mask";
		    
		   
		    
		       boolean m_creation=false;
		    
		       int m_typeFinder=0;
		    
		       boolean m_basicEdition=true;//En principio se permite la edicion de la columna pero siempre que enable este tambien a true
		    
		       boolean m_uniqueValue=false;//Indica si el valor de esta columna tiene que ser unico en base de datos

		       Integer m_redondeo=1;//Para saber el numero de digitos de redondeo en caso de ser un double
		    
		    /** El id del padre de la columna*/
		       String m_iIdParent=null;
		   GTableColumn column = new GTableColumn(			m_iId,		m_iIdParent,		m_iColumn,			m_strLabel,		m_iType,		m_ref,		m_idProp,		m_width,	m_height,	m_length,			m_mask,			m_enable,			m_hide,			m_total,		m_agrupable,		m_dobleSizeHeader,		m_nullable,			m_creation,		m_typeFinder,		m_basicEdition,			m_uniqueValue,m_redondeo);
		   return column;
	   }
	   public  GTableColumn buildDisplayName() {
	    	  /** El id de la columna*/
	          String m_iId = "displayName";
	          /** El índice de la columna (empezando desde 0)*/
	          int m_iColumn=0;
	          /** El nombre de la columna*/
	          String m_strLabel="Display Name";
	          /** El código del tipo de la columna*/
	          int m_iType=GConst.TM_TEXT;
	          /** Si la columna es editable*/
	          boolean m_enable=true;
	      	//No se tiene permiso para modificar este campo.
	          /** Si la columna está oculta o no*/
	          boolean m_hide=false;
	          /** Si se puede resumir en una*/
	           boolean m_total=true;
	          /** Si se puede agrupar en varios valores*/
	          boolean m_agrupable=true;
	          /** Id de la columna*/
	           int m_idProp=0;
	          /** Ancho de la columna*/
	         int m_width=100;
	          /** Alto de la columna*/
	         int m_height=120;
	          /** Longitud de la columna*/
	         int m_length=100;
	          /** */
	         String m_ref="m_ref";
	          /** */
	         boolean m_dobleSizeHeader = false;
	          /** Si acepta el valor nulo*/
	         boolean m_nullable=false;
	          /** Máscara aplicable*/
	         String m_mask="m_mask";
	          
	         
	          
	         boolean m_creation=false;
	          
	         int m_typeFinder=0;
	          
	         boolean m_basicEdition=true;//En principio se permite la edicion de la columna pero siempre que enable este tambien a true
	          
	         boolean m_uniqueValue=false;//Indica si el valor de esta columna tiene que ser unico en base de datos

	         Integer m_redondeo=1;//Para saber el numero de digitos de redondeo en caso de ser un double
	          
	          /** El id del padre de la columna*/
	         String m_iIdParent = null;
	          
	         GTableColumn column = new GTableColumn(			m_iId,		m_iIdParent,		m_iColumn,			m_strLabel,		m_iType,		m_ref,		m_idProp,		m_width,	m_height,	m_length,			m_mask,			m_enable,			m_hide,			m_total,		m_agrupable,		m_dobleSizeHeader,		m_nullable,			m_creation,		m_typeFinder,		m_basicEdition,			m_uniqueValue,m_redondeo);
	         return column;
	      }
	
	

    

}